---
description: PROMPTS: Sistema de Ensamblaje de Prompts
globs: src/core/prompt-engine/*
alwaysApply: true
---
# PROMPT ASSEMBLER - Ensamblaje Din√°mico de Prompts

## UBICACI√ìN

- `src/core/prompt-engine/assembler.ts` - L√≥gica de ensamblaje
- `src/core/prompt-engine/templates.ts` - Templates por tecnolog√≠a

---

## CONCEPTO

PromptAssembler construye prompts DIN√ÅMICOS que incluyen:
1. Contexto de la migraci√≥n (archivo, tecnolog√≠a)
2. Reglas de migraci√≥n (desde el manifiesto arquitect√≥nico)
3. Stack propuesto (si existe manifiesto)
4. Componentes similares (desde RAG)
5. Restricciones del proyecto

---

## ESTRUCTURA DEL PROMPT

```markdown
# üß¨ OSMOSIS - Legacy Code Migration

## CONTEXTO
- Archivo: {fileName}
- Tecnolog√≠a origen: {legacyLanguage}
- Framework destino: {targetFramework}

## C√ìDIGO LEGACY
```{legacyLanguage}
{legacyCode}
```

## üéØ STACK TECNOL√ìGICO REQUERIDO (desde manifiesto)
- State: {zustand/redux-toolkit}
- Fetching: {tanstack-query}
- Routing: {react-router-v6}
- Styling: {tailwind}

## üìã REGLAS DE MIGRACI√ìN

### State Management
1. ‚ùå NO usar connect(). ‚úÖ USAR useStore() de Zustand
2. ‚ùå NO usar mapStateToProps. ‚úÖ USAR selector functions
...

### Data Fetching
1. ‚ùå NO usar useEffect + fetch. ‚úÖ USAR useQuery()
2. ‚ùå NO usar axios manual. ‚úÖ USAR useMutation()
...

### Routing
1. ‚ùå NO usar <Switch>. ‚úÖ USAR <Routes>
2. ‚ùå NO usar withRouter. ‚úÖ USAR useNavigate
...

## üîç COMPONENTES EXISTENTES (RAG)
[Inyectado por ContextInjector]

## ‚úÖ REQUISITOS
1. TypeScript estricto (no any)
2. Functional components + Hooks
3. Props interfaces
4. Accesibilidad (aria-labels)
5. Solo el c√≥digo, sin explicaciones

## üì§ OUTPUT
```tsx
// C√≥digo migrado aqu√≠
```
```

---

## API

```typescript
interface PromptContext {
  fileName: string;
  filePath: string;
  legacyCode: string;
  legacyLanguage: string;
  targetFramework: string;
  additionalContext?: string;
  clientName?: string;
  projectType?: string;
  architectureManifest?: ArchitectureManifest;  // Para modo integral
}

class PromptAssembler {
  // Ensamblaje est√°ndar
  static assemble(context: PromptContext): string;
  
  // Ensamblaje integral (con manifiesto)
  static assembleIntegral(context: PromptContext, manifest: ArchitectureManifest): string;
  
  // Helpers privados
  private static getMigrationRulesSection(manifest: ArchitectureManifest): string;
  private static getProposedStackSection(manifest: ArchitectureManifest): string;
  private static getConsistencySection(manifest: ArchitectureManifest): string;
}
```

---

## M√âTODO: `assemble(context)`

Ensamblaje est√°ndar para migraciones archivo por archivo.

```typescript
static assemble(context: PromptContext): string {
  const template = getTemplate(context.legacyLanguage, context.targetFramework);
  
  let prompt = template
    .replace('{fileName}', context.fileName)
    .replace('{legacyCode}', context.legacyCode)
    .replace('{legacyLanguage}', context.legacyLanguage)
    .replace('{targetFramework}', context.targetFramework);
  
  // Si hay manifiesto, agregar reglas y stack
  if (context.architectureManifest) {
    const migrationRules = this.getMigrationRulesSection(context.architectureManifest);
    const stackSection = this.getProposedStackSection(context.architectureManifest);
    
    prompt = prompt
      .replace('{MIGRATION_RULES}', migrationRules)
      .replace('{PROPOSED_STACK}', stackSection);
  } else {
    // Reglas default sin manifiesto
    prompt = prompt
      .replace('{MIGRATION_RULES}', this.getDefaultMigrationRules(context))
      .replace('{PROPOSED_STACK}', '');
  }
  
  return prompt;
}
```

---

## M√âTODO: `assembleIntegral(context, manifest)`

Ensamblaje para modo integral con manifiesto arquitect√≥nico.

```typescript
static assembleIntegral(context: PromptContext, manifest: ArchitectureManifest): string {
  const base = this.assemble({
    ...context,
    architectureManifest: manifest
  });
  
  // Agregar secci√≥n de consistencia global
  const consistencySection = this.getConsistencySection(manifest);
  
  return `${base}

## üèóÔ∏è CONSISTENCIA GLOBAL

**IMPORTANTE**: Este archivo es parte de un proyecto con ${manifest.patternAnalysis.summary.totalComponents} componentes.
La modernizaci√≥n debe ser COHERENTE con el resto del proyecto.

${consistencySection}

### Imports Esperados (usa estos, no otros)
${this.getStackImports(manifest)}
`;
}
```

---

## SECCIONES INYECTADAS

### Stack Propuesto

```typescript
private static getProposedStackSection(manifest: ArchitectureManifest): string {
  const { proposedStack } = manifest;
  
  return `
## üéØ STACK TECNOL√ìGICO REQUERIDO

**OBLIGATORIO: Usar EXACTAMENTE estas tecnolog√≠as:**

| Categor√≠a | Librer√≠a | Raz√≥n |
|-----------|----------|-------|
| State | **${proposedStack.stateManagement.library}** | ${proposedStack.stateManagement.reasoning} |
| Fetching | **${proposedStack.dataFetching.library}** | ${proposedStack.dataFetching.reasoning} |
| Routing | **${proposedStack.routing.library}** | ${proposedStack.routing.reasoning} |
| Styling | **${proposedStack.styling.library}** | ${proposedStack.styling.reasoning} |
| Forms | **${proposedStack.forms.library}** | ${proposedStack.forms.reasoning} |
| Testing | **${proposedStack.testing.library}** | ${proposedStack.testing.reasoning} |

‚ö†Ô∏è **NO usar alternativas**: Si el stack dice Zustand, NO usar Redux ni Context.
`;
}
```

### Reglas de Migraci√≥n

```typescript
private static getMigrationRulesSection(manifest: ArchitectureManifest): string {
  const rules = manifest.migrationRules;
  
  // Agrupar por categor√≠a
  const grouped = this.groupRulesByCategory(rules);
  
  let section = '## üìã REGLAS DE MIGRACI√ìN ESPEC√çFICAS\n\n';
  
  for (const [category, categoryRules] of Object.entries(grouped)) {
    section += `### ${this.getCategoryTitle(category)}\n\n`;
    
    for (const rule of categoryRules) {
      section += `#### ${rule.name} ${rule.isCritical ? 'üî¥' : ''}\n`;
      section += `- ‚ùå Detecta: \`${rule.detectPattern}\`\n`;
      section += `- ‚úÖ Transformar a: ${rule.transformInstruction}\n`;
      section += `\n**Ejemplo:**\n`;
      section += `\`\`\`typescript\n// ANTES\n${rule.example.before}\n\n// DESPU√âS\n${rule.example.after}\n\`\`\`\n\n`;
    }
  }
  
  return section;
}
```

### Imports Esperados

```typescript
private static getStackImports(manifest: ArchitectureManifest): string {
  const { proposedStack } = manifest;
  const imports: string[] = [];
  
  // State
  switch (proposedStack.stateManagement.library) {
    case 'zustand':
      imports.push("import { create } from 'zustand';");
      imports.push("import { useXxxStore } from '@/stores/xxxStore';");
      break;
    case 'redux-toolkit':
      imports.push("import { useSelector, useDispatch } from 'react-redux';");
      imports.push("import type { RootState, AppDispatch } from '@/store';");
      break;
  }
  
  // Fetching
  switch (proposedStack.dataFetching.library) {
    case 'tanstack-query':
      imports.push("import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';");
      break;
    case 'swr':
      imports.push("import useSWR from 'swr';");
      break;
  }
  
  // Routing
  switch (proposedStack.routing.library) {
    case 'react-router-v6':
    case 'react-router-v7':
      imports.push("import { useNavigate, useParams, useLocation } from 'react-router-dom';");
      break;
  }
  
  // Forms
  switch (proposedStack.forms.library) {
    case 'react-hook-form':
      imports.push("import { useForm } from 'react-hook-form';");
      imports.push("import { zodResolver } from '@hookform/resolvers/zod';");
      break;
  }
  
  return `\`\`\`typescript\n${imports.join('\n')}\n\`\`\``;
}
```

---

## TEMPLATES POR TECNOLOG√çA

### Template JSP ‚Üí React

```markdown
# üß¨ JSP to React Migration

## Contexto
- Archivo JSP: {fileName}
- Output: React TypeScript Component

## C√≥digo JSP Original
```jsp
{legacyCode}
```

## Mapeo JSP ‚Üí React
| JSP | React |
|-----|-------|
| `<c:if test="${...}">` | `{condition && <.../>}` |
| `<c:forEach items="${...}">` | `{items.map(item => ...)}` |
| `<c:set var="..." value="...">` | `const [var, setVar] = useState(...)` |
| `${requestScope.data}` | Props o state |
| `<form action="..." method="post">` | `<form onSubmit={handleSubmit}>` |

## Requisitos
1. Extraer l√≥gica Java a hooks/services
2. Convertir JSTL a JSX
3. Manejar formularios con React Hook Form
4. TypeScript estricto
```

### Template PHP ‚Üí React

```markdown
# üß¨ PHP to React Migration

## Contexto
- Archivo PHP: {fileName}
- Output: React TypeScript Component + API calls

## C√≥digo PHP Original
```php
{legacyCode}
```

## Mapeo PHP ‚Üí React
| PHP | React |
|-----|-------|
| `<?php echo $var ?>` | `{var}` |
| `<?php if (...): ?>` | `{condition && <.../>}` |
| `<?php foreach ($items as $item): ?>` | `{items.map(item => ...)}` |
| `$_GET['param']` | `useSearchParams()` |
| `$_POST['data']` | Form state + fetch POST |
| `mysql_query(...)` | `useQuery({ queryFn: fetchData })` |

## Requisitos
1. Separar l√≥gica de servidor (API) y cliente (React)
2. Reemplazar llamadas MySQL por fetch a API
3. Eliminar funciones inseguras (eval, mysql_*)
```

### Template jQuery ‚Üí React

```markdown
# üß¨ jQuery to React Migration

## Contexto
- Archivo JS: {fileName}
- Output: React TypeScript Component

## C√≥digo jQuery Original
```javascript
{legacyCode}
```

## Mapeo jQuery ‚Üí React
| jQuery | React |
|--------|-------|
| `$('#element')` | `useRef()` |
| `$('.class').hide()` | State + conditional rendering |
| `$(document).ready()` | `useEffect(..., [])` |
| `$('#btn').click(fn)` | `onClick={fn}` |
| `$.ajax({ url, success })` | `useQuery()` o `fetch` |
| `$('#input').val()` | Controlled input con `useState` |
| `$('#el').append(html)` | Array state + map |

## Requisitos
1. Eliminar TODA manipulaci√≥n directa del DOM
2. Convertir a componentes controlados
3. Reemplazar jQuery UI con componentes modernos
```

---

## EJEMPLO DE PROMPT COMPLETO

```markdown
# üß¨ OSMOSIS - Legacy Code Migration

## CONTEXTO
- Archivo: UserDashboard.jsx
- Tecnolog√≠a origen: react-legacy
- Framework destino: react

## C√ìDIGO LEGACY
```jsx
import { connect } from 'react-redux';
import { withRouter } from 'react-router-dom';

class UserDashboard extends Component {
  componentDidMount() {
    axios.get('/api/users').then(r => this.setState({ users: r.data }));
  }
  
  render() {
    return <div style={{ padding: 20 }}>{/* ... */}</div>;
  }
}

export default withRouter(connect(mapStateToProps)(UserDashboard));
```

## üéØ STACK TECNOL√ìGICO REQUERIDO

| Categor√≠a | Librer√≠a |
|-----------|----------|
| State | **zustand** |
| Fetching | **tanstack-query** |
| Routing | **react-router-v6** |
| Styling | **tailwind** |

## üìã REGLAS DE MIGRACI√ìN

### State Management
1. ‚ùå `connect(mapStateToProps)` ‚Üí ‚úÖ `useStore()`
2. ‚ùå `this.props.dispatch` ‚Üí ‚úÖ Actions de Zustand

### Data Fetching  
1. ‚ùå `componentDidMount + axios` ‚Üí ‚úÖ `useQuery()`

### Routing
1. ‚ùå `withRouter` ‚Üí ‚úÖ `useNavigate()`

### Components
1. ‚ùå `class extends Component` ‚Üí ‚úÖ `function Component()`

### Styling
1. ‚ùå `style={{ padding: 20 }}` ‚Üí ‚úÖ `className="p-5"`

## üîç COMPONENTES EXISTENTES
[Lista de componentes similares del Knowledge Graph]

## ‚úÖ REQUISITOS
1. TypeScript estricto
2. Functional components
3. Sin class components
4. Sin connect/withRouter
5. TanStack Query para fetching
6. Tailwind para estilos

## üì§ OUTPUT
```tsx
// Tu c√≥digo aqu√≠
```
```
