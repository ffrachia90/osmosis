---
description: GRAPH: Sistema de Grafo de Dependencias
globs: src/core/analysis/*
alwaysApply: true
---
# DEPENDENCY GRAPH - Grafo de Dependencias con AST

## UBICACI√ìN

`src/core/analysis/DependencyGraph.ts`

---

## CONCEPTO

DependencyGraph construye un grafo de dependencias usando **AST parsing** (no regex) para:
1. Determinar el orden de migraci√≥n (topological sort)
2. Detectar ciclos de dependencias
3. Identificar entry points
4. Calcular impacto de cambios

---

## API

```typescript
interface FileNode {
  path: string;
  imports: string[];          // Archivos que importa
  exports: string[];          // Exports p√∫blicos
  dependants: string[];       // Archivos que lo importan
  isEntryPoint: boolean;      // Sin dependants
}

interface DependencyGraphResult {
  nodes: Map<string, FileNode>;
  migrationOrder: string[];   // Orden topol√≥gico
  cycles: string[][];         // Ciclos detectados
  entryPoints: string[];      // Archivos sin dependants
  leafNodes: string[];        // Archivos sin imports
}

class DependencyGraph {
  async build(projectDir: string): Promise<DependencyGraphResult>;
  getMigrationOrder(): string[];
  detectCycles(): string[][];
  getImpact(filePath: string): string[];  // ¬øQu√© se rompe si cambio esto?
}
```

---

## PARSING DE IMPORTS

### TypeScript Compiler API

```typescript
import * as ts from 'typescript';

function extractImports(filePath: string): string[] {
  const sourceFile = ts.createSourceFile(
    filePath,
    fs.readFileSync(filePath, 'utf-8'),
    ts.ScriptTarget.Latest,
    true
  );
  
  const imports: string[] = [];
  
  function visit(node: ts.Node) {
    // import X from './module'
    if (ts.isImportDeclaration(node)) {
      const moduleSpecifier = node.moduleSpecifier;
      if (ts.isStringLiteral(moduleSpecifier)) {
        imports.push(moduleSpecifier.text);
      }
    }
    
    // export { X } from './module'
    if (ts.isExportDeclaration(node) && node.moduleSpecifier) {
      if (ts.isStringLiteral(node.moduleSpecifier)) {
        imports.push(node.moduleSpecifier.text);
      }
    }
    
    // require('./module')
    if (ts.isCallExpression(node) && 
        node.expression.getText() === 'require' &&
        node.arguments.length > 0) {
      const arg = node.arguments[0];
      if (ts.isStringLiteral(arg)) {
        imports.push(arg.text);
      }
    }
    
    // Dynamic import()
    if (ts.isCallExpression(node) &&
        node.expression.kind === ts.SyntaxKind.ImportKeyword) {
      const arg = node.arguments[0];
      if (ts.isStringLiteral(arg)) {
        imports.push(arg.text);
      }
    }
    
    ts.forEachChild(node, visit);
  }
  
  visit(sourceFile);
  return imports;
}
```

---

## RESOLUCI√ìN DE PATHS

```typescript
// Resuelve imports relativos y aliases

function resolveImportPath(
  importPath: string,
  sourceFile: string,
  projectRoot: string,
  tsconfig?: TsConfig
): string {
  // 1. Imports relativos
  if (importPath.startsWith('.')) {
    return path.resolve(path.dirname(sourceFile), importPath);
  }
  
  // 2. Path aliases (desde tsconfig)
  if (tsconfig?.compilerOptions?.paths) {
    for (const [alias, targets] of Object.entries(tsconfig.compilerOptions.paths)) {
      const pattern = alias.replace('/*', '');
      if (importPath.startsWith(pattern)) {
        const target = targets[0].replace('/*', '');
        const resolvedPath = importPath.replace(pattern, target);
        return path.resolve(projectRoot, resolvedPath);
      }
    }
  }
  
  // 3. node_modules (ignorar)
  return importPath; // External dependency
}
```

---

## TOPOLOGICAL SORT

```typescript
// Ordena archivos para migrar en orden correcto
// (primero los que no tienen dependencias)

function topologicalSort(nodes: Map<string, FileNode>): string[] {
  const sorted: string[] = [];
  const visited = new Set<string>();
  const visiting = new Set<string>();
  
  function visit(nodePath: string) {
    if (visited.has(nodePath)) return;
    if (visiting.has(nodePath)) {
      // Ciclo detectado
      throw new Error(`Circular dependency: ${nodePath}`);
    }
    
    visiting.add(nodePath);
    
    const node = nodes.get(nodePath);
    if (node) {
      for (const dep of node.imports) {
        if (nodes.has(dep)) {
          visit(dep);
        }
      }
    }
    
    visiting.delete(nodePath);
    visited.add(nodePath);
    sorted.push(nodePath);
  }
  
  for (const nodePath of nodes.keys()) {
    visit(nodePath);
  }
  
  return sorted;
}
```

**Resultado**: El orden garantiza que cuando migramos un archivo, todas sus dependencias ya est√°n migradas.

---

## DETECCI√ìN DE CICLOS

```typescript
function detectCycles(nodes: Map<string, FileNode>): string[][] {
  const cycles: string[][] = [];
  const visited = new Set<string>();
  
  function dfs(nodePath: string, path: string[], visited: Set<string>) {
    if (path.includes(nodePath)) {
      // Encontrado ciclo
      const cycleStart = path.indexOf(nodePath);
      cycles.push(path.slice(cycleStart));
      return;
    }
    
    if (visited.has(nodePath)) return;
    
    visited.add(nodePath);
    path.push(nodePath);
    
    const node = nodes.get(nodePath);
    if (node) {
      for (const dep of node.imports) {
        if (nodes.has(dep)) {
          dfs(dep, [...path], visited);
        }
      }
    }
  }
  
  for (const nodePath of nodes.keys()) {
    dfs(nodePath, [], new Set());
  }
  
  return cycles;
}
```

---

## AN√ÅLISIS DE IMPACTO

```typescript
// ¬øQu√© archivos se rompen si cambio este?

function getImpact(filePath: string, nodes: Map<string, FileNode>): string[] {
  const impacted = new Set<string>();
  const queue = [filePath];
  
  while (queue.length > 0) {
    const current = queue.shift()!;
    const node = nodes.get(current);
    
    if (node) {
      for (const dependant of node.dependants) {
        if (!impacted.has(dependant)) {
          impacted.add(dependant);
          queue.push(dependant);
        }
      }
    }
  }
  
  return Array.from(impacted);
}
```

---

## IDENTIFICACI√ìN DE ENTRY POINTS

```typescript
// Archivos que nadie importa (entry points de la app)

function findEntryPoints(nodes: Map<string, FileNode>): string[] {
  const entryPoints: string[] = [];
  
  for (const [path, node] of nodes) {
    if (node.dependants.length === 0) {
      // Nadie lo importa = entry point
      entryPoints.push(path);
    }
  }
  
  // Tambi√©n detectar por nombre
  const commonEntryNames = ['index', 'main', 'app', 'App', 'entry', 'bootstrap'];
  
  return entryPoints.filter(ep => 
    commonEntryNames.some(name => ep.includes(name))
  );
}
```

---

## VISUALIZACI√ìN

```typescript
function visualizeGraph(nodes: Map<string, FileNode>): string {
  let output = 'üìä DEPENDENCY GRAPH\n';
  output += '‚ïê'.repeat(50) + '\n\n';
  
  // Entry points
  const entryPoints = findEntryPoints(nodes);
  output += 'üö™ Entry Points:\n';
  for (const ep of entryPoints) {
    output += `   ‚îî‚îÄ ${ep}\n`;
  }
  output += '\n';
  
  // Leaf nodes (sin imports)
  const leafNodes = Array.from(nodes.entries())
    .filter(([_, node]) => node.imports.length === 0)
    .map(([path]) => path);
  
  output += 'üçÉ Leaf Nodes (sin dependencias):\n';
  for (const leaf of leafNodes.slice(0, 5)) {
    output += `   ‚îî‚îÄ ${leaf}\n`;
  }
  if (leafNodes.length > 5) {
    output += `   ‚îî‚îÄ ... y ${leafNodes.length - 5} m√°s\n`;
  }
  output += '\n';
  
  // Ciclos
  const cycles = detectCycles(nodes);
  if (cycles.length > 0) {
    output += 'üîÑ Ciclos Detectados (PROBLEMA):\n';
    for (const cycle of cycles) {
      output += `   ‚ö†Ô∏è ${cycle.join(' ‚Üí ')}\n`;
    }
  } else {
    output += '‚úÖ Sin ciclos de dependencias\n';
  }
  
  return output;
}
```

---

## EJEMPLO DE OUTPUT

```
üìä DEPENDENCY GRAPH
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üö™ Entry Points:
   ‚îî‚îÄ src/index.tsx
   ‚îî‚îÄ src/App.tsx

üçÉ Leaf Nodes (sin dependencias):
   ‚îî‚îÄ src/utils/constants.ts
   ‚îî‚îÄ src/types/index.ts
   ‚îî‚îÄ src/utils/helpers.ts
   ‚îî‚îÄ ... y 12 m√°s

‚úÖ Sin ciclos de dependencias

üìà Estad√≠sticas:
   ‚Ä¢ Total archivos: 234
   ‚Ä¢ Total imports: 1,456
   ‚Ä¢ Profundidad m√°xima: 8 niveles
   ‚Ä¢ Archivos m√°s importados:
     1. src/components/Button.tsx (45 veces)
     2. src/hooks/useAuth.ts (38 veces)
     3. src/utils/api.ts (32 veces)

üîÄ Orden de Migraci√≥n:
   1. src/types/index.ts
   2. src/utils/constants.ts
   3. src/utils/helpers.ts
   4. src/hooks/useAuth.ts
   5. src/components/Button.tsx
   ... (234 archivos total)
```

---

## USO EN MIGRACI√ìN

```typescript
// En cli.ts durante migraci√≥n

const graph = await dependencyGraph.build(projectDir);

console.log('üìä Grafo de dependencias construido');
console.log(`   Archivos: ${graph.nodes.size}`);
console.log(`   Entry points: ${graph.entryPoints.length}`);
console.log(`   Ciclos: ${graph.cycles.length}`);

if (graph.cycles.length > 0) {
  console.warn('‚ö†Ô∏è Ciclos detectados. Pueden causar problemas.');
}

// Migrar en orden topol√≥gico
const migrationOrder = graph.getMigrationOrder();

for (const filePath of migrationOrder) {
  console.log(`[${index}/${migrationOrder.length}] Migrando ${filePath}...`);
  await migrateFile(filePath);
}
```

---

## PATH RESOLVER

### Ubicaci√≥n: `src/core/resolution/PathResolver.ts`

Resuelve paths con soporte para:
- Imports relativos (`./`, `../`)
- Path aliases (`@/components`)
- tsconfig.json paths
- Index files (`./folder` ‚Üí `./folder/index.ts`)
- Extensions (`.ts`, `.tsx`, `.js`, `.jsx`)

```typescript
class PathResolver {
  constructor(projectRoot: string, tsconfigPath?: string);
  
  // Resuelve un import a path absoluto
  resolve(importPath: string, fromFile: string): string | null;
  
  // Verifica si un path existe (con extensiones)
  exists(path: string): boolean;
  
  // Obtiene el archivo real (resolviendo index, extensiones)
  getRealPath(path: string): string | null;
}
```
